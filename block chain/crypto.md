# 公钥与私钥

A把要加密的内容用私钥加密，发给B，B收到后用公钥解密。反之相同。  

# 数字签名

A把要加密的内容用hash函数生成摘要digest，再用私钥对digest加密，生成数字签名signature。连同加密的内容一起发给B。  
B收到后，对摘要和内容都用公钥解密，再对内容使用相同hash，看得到的digest是否相同，相同，说明发送的内容没有被修改。  
但是如果B的公钥被替换了，就可能出现收到伪造的内容和签名而不知道。

# 数字证书

证书中心用自己的私钥对A的公钥和一些相关信息一起加密，形成数字证书。  
A在发送内容的同时，在数字签名后再附上数字证书。  
B收到后，先用CA的公钥解密数字证书，得到A真正的公钥，再用A的公钥来验证签名是否是A的签名。  

B可以每次都到CA的网站上（或者什么别的官方途径）获得CA的公钥。

这么做的目的是为了验签：1.确认该信息确实是A所发；2.确认A发出的信息是完整的。

**公钥防泄漏,私钥防篡改**
其实完整的过程应该是A用B的公钥加密内容，再用自己的私钥加密签名，再附上自己的证书。  
B收到后，只有用B自己的私钥才能解密内容，别人是无法解密的。`防泄漏`  
再用上述数字证书来验证数字签名是否来自A，发送内容有没有被篡改。`防篡改`

# 非对称加密

加解密密钥不相关，典型如RSA、EIGamal、椭圆曲线算法。

# 椭圆曲线加密

公开密钥算法总是要基于一个数学上的难题。比如RSA 依据的是：给定两个素数p、q 很容易相乘得到n，而对n进行因式分解却相对困难。那椭圆曲线上有什么难题呢？

考虑如下等式：  
K=kG  [其中 K,G为Ep(a,b)上的点，k为小于n（n是点G的阶）的整数]  
`不难发现，给定k和G，根据加法法则，计算K很容易；但给定K和G，求k就相对困难了。`  
这就是椭圆曲线加密算法采用的难题。我们把点G称为基点（base point）  

现在我们描述一个利用椭圆曲线进行加密通信的过程：  

1.  用户A选定一条椭圆曲线Ep(a,b)，并取椭圆曲线上一点，作为基点G。
2.  用户A选择一个私有密钥k，并生成`公开密钥K=kG`。
3.  用户A将Ep(a,b)和点K，G传给用户B。
4.  用户B接到信息后 ，将待传输的明文编码到Ep(a,b)上一点M（编码方法很多，这里不作讨论），并产生一个随机整数r
5.  用户B计算点C1=M+rK；C2=rG。
6.  用户B将C1、C2传给用户A。
7.  用户A接到信息后，计算C1-kC2，结果就是点M。因为
    C1-kC2=M+rK-k(rG)=M+rK-r(kG)=M  
    再对点M进行解码就可以得到明文。

在这个加密通信中，如果有一个偷窥者H，他只能看到Ep(a,b)、K、G、C1、C2，`而通过K、G 求k 或通过C2、G求r 都是相对困难的`。因此，H无法得到A、B间传送的明文信息。

# Merkle Tree

默克尔树，又叫哈希树，由一个root节点，一组中间节点和一组叶节点组成。  
叶节点包含存储数据或者其哈希值，中间节点和root节点都是其孩子的hash值。  

![markle tree](./img/markle%20tree.jpg)

应用：
1.  快速比较数据，两个默克尔树的根节点相同，那么其所代表的数据必然相同
2.  快速定位修改，比如上面D1数据被修改，可通过root->N4->N1，快速定位到发生改变的D1
3.  零知识证明，比如要证明某个数据中包含D0，那就构造一个默克尔树，公开root、N4、N1、N0，D0拥有者可以检测到D0存在，但不知道其他内容。（D0拥有者可以看到hash值，但看不到完整的数据内容）
